<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><title>Go Generics で実装する Y コンビネータ、再帰関数を汎用的にメモ化する - アルパカの徒然文</title><meta name="description" content="Go のジェネリクスのコードを利用し Y コンビネータ（不動点演算子）を実装することで再帰関数の汎用化を狙う。実装したものにプラグイン機構を用意することで結果のメモ化の汎用化を行う。"/><link rel="canonical" href="https://codehex.dev/note/y_combinator_in_go_generics"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@codehex"/><meta property="og:url" content="https://codehex.dev/note/y_combinator_in_go_generics"/><meta property="og:title" content="Go Generics で実装する Y コンビネータ、再帰関数を汎用的にメモ化する - アルパカの徒然文"/><meta property="og:image" content="https://codehex.dev/assets/images/350e63b3dcf2d00d0ebc8b16d189e38c.png"/><meta property="og:description" content="Go のジェネリクスのコードを利用し Y コンビネータ（不動点演算子）を実装することで再帰関数の汎用化を狙う。実装したものにプラグイン機構を用意することで結果のメモ化の汎用化を行う。"/><meta property="og:type" content="article"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="next-head-count" content="12"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8097329174824434" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/cb05f45700160405.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cb05f45700160405.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-fecce247ebec0a1a.js" defer=""></script><script src="/_next/static/chunks/framework-0ba0ddd33199226d.js" defer=""></script><script src="/_next/static/chunks/main-3e1f83e356353203.js" defer=""></script><script src="/_next/static/chunks/pages/_app-29c235e094f245c1.js" defer=""></script><script src="/_next/static/chunks/186-81857d9b3c3c717c.js" defer=""></script><script src="/_next/static/chunks/55-8174b7f62ba27649.js" defer=""></script><script src="/_next/static/chunks/327-407bbdfad760cb5f.js" defer=""></script><script src="/_next/static/chunks/pages/note/y_combinator_in_go_generics-6becf2e20d4c965a.js" defer=""></script><script src="/_next/static/d3f8ba3332610b55217f7802de0371966a505fe6/_buildManifest.js" defer=""></script><script src="/_next/static/d3f8ba3332610b55217f7802de0371966a505fe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main role="main" class="w-full mx-auto max-w-3xl xl:max-w-5xl"><div class="w-full bg-white antialiased"><div class="mx-8 sm:mx-10 md:mx-12 pt-10 pb-16"><div class="pb-2 border-b border-gray-200 mb-10"><h1 class="inline-block text-3xl font-bold text-gray-900 tracking-tight">Go Generics で実装する Y コンビネータ、再帰関数を汎用的にメモ化する</h1><div class="text-sm sm:text-base whitespace-nowrap text-gray-500"><div class="sr-only">Published on</div><time dateTime="2022-06-13T10:47:25+09:00">June 13, 2022<!-- --> (<!-- -->2 months ago<!-- -->)</time></div><div aria-label="タグ一覧" class="flex flex-wrap gap-2"><a role="link" class="w-max inline-flex rounded-sm bg-blue-100 hover:bg-blue-600 px-2 py-0.5 text-sm" href="/note/tags/Go/"><span class="font-medium text-blue-700 hover:text-white"># <!-- -->Go</span></a><a role="link" class="w-max inline-flex rounded-sm bg-blue-100 hover:bg-blue-600 px-2 py-0.5 text-sm" href="/note/tags/golang/"><span class="font-medium text-blue-700 hover:text-white"># <!-- -->golang</span></a></div></div><article role="article" class="prose sm:prose-sm md:prose-md"><p>先日面白い記事を読んだ。<a href="https://eli.thegreenplace.net/2022/the-y-combinator-in-go-with-generics/">The Y combinator in Go with generics</a> である。</p>
<p>一番最初目に入ってきたのは難解なジェネリクスのコードである。</p>
<pre><code class="language-go">type Func[T, U any] func(T) U
type TagFunc[T, U any] func(Func[T, U]) Func[T, U]
type CombinatorFunc[T, U any] func(CombinatorFunc[T, U]) Func[T, U]

func Y[T, U any](f TagFunc[T, U]) Func[T, U] {
  return func(self CombinatorFunc[T, U]) Func[T, U] {
    return f(func(n T) U {
      return self(self)(n)
    })
  }(func(self CombinatorFunc[T, U]) Func[T, U] {
    return f(func(n T) U {
      return self(self)(n)
    })
  })
}
</code></pre>
<p>このコードを読み解くために、<strong>Y コンビネータ</strong><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>というものを理解する必要がある。そのためには前提となる無名関数を利用した処理を行うコードを理解しておくとよりわかりやすくなる。なぜならこの Y コンビネータは再帰を用いた無名関数呼び出しを行うことでループ処理を実現する機構として利用できるからである。</p>
<h2 id="引数を一つにする"><a href="#%E5%BC%95%E6%95%B0%E3%82%92%E4%B8%80%E3%81%A4%E3%81%AB%E3%81%99%E3%82%8B" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>引数を一つにする</h2>
<p>Go は無名関数を作成できる。足し算を行うようなコードを記述するとこんな感じ。</p>
<pre><code class="language-go">sum := func(x, y int) int { return x + y }
sum(1, 2) // 3
</code></pre>
<p>引数を 2 つ受け付けるようにしているが、1 つの引数で同様の挙動を実現させようとするとどうすべきだろうか。「カリー化」と呼ばれる手法を用いることでこれを実現する。
この手法は端的に言えば「<strong>複数の引数を1つに減らす</strong>」ための手法である。</p>
<p>まずは定義した足し算を行う無名関数の y を 2 で固定した add3 関数を考える。</p>
<pre><code class="language-go">add2 := func(x int) int { return sum(x, 2) }
add2(1) // 3
</code></pre>
<p>しかし、<code>2</code> の箇所も引数として指定することで自由に計算できるようにしたい。そこで後で引数を指定してもらえるように、<code>y</code> を引数に取るような無名関数を返す形で定義する。</p>
<pre><code class="language-go">add := func(x int) func(y int) int {
  return func(y int) int { // y を引数に取る関数を返す
    return sum(x, y)
  }
}
add1 := add(1)
add1(2) // 3
</code></pre>
<p>こうして複数の引数を持つ関数を 1 引数の関数に変換できる。</p>
<h2 id="無名関数での再帰"><a href="#%E7%84%A1%E5%90%8D%E9%96%A2%E6%95%B0%E3%81%A7%E3%81%AE%E5%86%8D%E5%B8%B0" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>無名関数での再帰</h2>
<h3 id="階乗の計算"><a href="#%E9%9A%8E%E4%B9%97%E3%81%AE%E8%A8%88%E7%AE%97" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>階乗の計算</h3>
<p>階乗の計算を行う再帰関数を考える。0 の階乗を計算すると 1 となる。それ以外の計算方法は <code>n! = n * (n - 1)!</code> となる法則がある。まとめるとこんな感じ。</p>
<pre><code>0! = 1
n! = n * (n - 1)!
</code></pre>
<p>これを素直にコードへ変換することができる。</p>
<pre><code class="language-go">func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n - 1)
}

factorial(10) // 3628800
</code></pre>
<p>さて、これは無名関数で表すことができるのだろうか。一番最初に思いつく素直な方法は次のようなコードだろう。しかしこれだと <code>undefined: factorial</code> のメッセージと共にコンパイルエラーになる。</p>
<pre><code class="language-go">factorial := func(n int) int {
  if n == 0 {
    return 1
  }
  return n * factorial(n-1) // undefined: factorial
}
</code></pre>
<p>ではどうすれば良いのか。少し複雑になるがその方法をここに記述する。</p>
<pre><code class="language-go">type FactorialFunc func(int) int
type FactorialMakerFunc func(FactorialMakerFunc) FactorialFunc

factorialMaker := func(self FactorialMakerFunc) FactorialFunc {
  return func(n int) int {
    if n == 0 {
      return 1
    }
    return n * self(self)(n-1)
  }
}
factorial := factorialMaker(factorialMaker)
factorial(10) // 3628800
</code></pre>
<ol>
<li><code>factorialMaker</code> は階乗の計算を行わない。代わりに無名関数を返す。この無名関数は <code>factorialMaker</code> が返したのと同じ関数を受け取ることを期待している。</li>
<li><code>factorial := factorialMaker(factorialMaker)</code> では <code>factorialMaker</code> が返す無名関数に <code>factorialMaker</code> 自身を渡すことで階乗の計算を行う無名関数を完成させる。</li>
<li><code>factorial(10)</code> で実際に階乗の計算を行う。</li>
</ol>
<p>同様にフィボナッチ数を求める計算についても考えてみる。</p>
<h3 id="フィボナッチ数の計算"><a href="#%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0%E3%81%AE%E8%A8%88%E7%AE%97" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>フィボナッチ数の計算</h3>
<p>フィボナッチ数列は以下のような数列である。</p>
<pre><code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...
</code></pre>
<p>この数列は次のような法則で成り立っていることが分かる。</p>
<pre><code>n = 0 =&gt; 0
n = 1 =&gt; 1
n = fib(n-1) + fib(n-2)
</code></pre>
<p>これを基に n 番目のフィボナッチ数を求める名前付き関数を定義する。</p>
<pre><code class="language-go">func fib(n int) int {
  if n &lt;= 1 {
    return n
  }
  return fib(n-1) + fib(n-2)
}

fib(10) // 55
</code></pre>
<p>これも階乗の計算と同じように無名関数を利用して表現してみる。</p>
<pre><code class="language-go">type FibFunc func(int) int
type FibMakerFunc func(FibMakerFunc) FibFunc

fibMaker := func(self FibMakerFunc) FibFunc {
  return func(n int) int {
    if n &lt;= 1 {
      return n
    }
    fib := self(self)
    return fib(n-1) + fib(n-2)
  }
}
fib := fibMaker(fibMaker)
fib(10) // 55
</code></pre>
<p>このコードも階乗の計算を行う無名関数と似たアプローチで作成できた。これまでの実装を見てみると、この無名関数の再帰呼び出しを行う仕組みは汎用化することができそうである。この汎用化の部分が<strong>Y コンビネータ</strong>になる。</p>
<h2 id="y-コンビネータ"><a href="#y-%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>Y コンビネータ</h2>
<p>もう一度冒頭の難解なジェネリクスのコードを見てみよう。これは次のように少しシンプルに修正できる。これで少しは読みやすくなっただろうか。
無名関数を束縛した <code>g</code> は自身を受け付けることで再帰処理部分を汎用的に切り出すことができている。</p>
<pre><code class="language-go">type Func[T, U any] func(T) U
type TagFunc[T, U any] func(Func[T, U]) Func[T, U]
type CombinatorFunc[T, U any] func(CombinatorFunc[T, U]) Func[T, U]

func Y[T, U any](f TagFunc[T, U]) Func[T, U] {
  g := func(self CombinatorFunc[T, U]) Func[T, U] {
    return f(func(t T) U {
      return self(self)(t)
    })
  }
  return g(g)
}
</code></pre>
<p>このコードを理解するために筆者が理解したことを記述する。</p>
<ol>
<li>引数 1 つで何か一つ返す関数型 <code>Func</code> を定義する。</li>
<li><code>TagFunc</code> が実際に処理を行うための無名関数の型になる。</li>
<li><code>CombinatorFunc</code> は関数 <code>Y</code> の中で利用される。この型を持つ <code>self</code> を <code>self(self)</code> とすることで引数である <code>TagFunc</code> と同じ関数が生成される。</li>
</ol>
<p>この関数 <code>Y</code> は以下のような使い方ができる。</p>
<pre><code class="language-go">factorial := Y(func(self Func[int, int]) Func[int, int] {
  return func(n int) int {
    if n == 0 {
      return 1
    }
    return n * self(n-1)
  }
})

factorial(10) // 3628800
</code></pre>
<p>以上のように Y コンビネータを利用することで無名関数で再帰処理を記述することができた。そして冒頭で挙げたコードを少し理解できたのではないだろうか。</p>
<p>「<a href="https://r-west.hatenablog.com/entry/20090417/1239972722">おとうさんにもわかるYコンビネータ！(絵解き解説編)</a>」の記事で詳しく記述されていたので非常に参考になった。</p>
<h2 id="関数のプラグイン機構を用意する"><a href="#%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E6%A9%9F%E6%A7%8B%E3%82%92%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>関数のプラグイン機構を用意する</h2>
<p>名前付き関数でも再帰処理を記述できるため、この Y コンビネータの利用シーンは少ないと思われるかもしれない。
しかし、汎用化できたということは当然再帰処理の結果をメモすることも汎用的に実装できるはずである。そこで Y コンビネータへ Pluggable に適用できるような関数 <code>Adapt</code> を定義する。</p>
<p>これらのコードは「<a href="https://r-west.hatenablog.com/entry/20090422/1240400570">さあ、Yコンビネータ(不動点演算子)を使おう！</a>」の内容を基に作成してみた。</p>
<pre><code class="language-go">func Adapt[T, U any](f TagFunc[T, U], adapters ...TagFunc[T, U]) TagFunc[T, U] {
  return func(self Func[T, U]) Func[T, U] {
    for i := len(adapters) - 1; i &gt;= 0; i-- {
      self = adapters[i](self)
    }
    return f(self)
  }
}
</code></pre>
<h3 id="メモ化プラグイン"><a href="#%E3%83%A1%E3%83%A2%E5%8C%96%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>メモ化プラグイン</h3>
<p>次にメモ化を行うプラグイン関数を定義する。</p>
<pre><code class="language-go">func Memo[T comparable, U any]() TagFunc[T, U] {
  memo := map[T]U{}
  return func(f Func[T, U]) Func[T, U] {
    return func(t T) U {
      result, ok := memo[t]
      if ok {
        return result
      }
      tmp := f(t)
      memo[t] = tmp
      return tmp
    }
  }
}
</code></pre>
<p>map を用いたシンプルなコードである。</p>
<ol>
<li>map <code>memo</code> を作成する。キーは comparable である必要がある。</li>
<li>入力値 <code>t</code> のメモが存在すればその値を返し、存在しなければ実行関数 <code>f</code> を実行し、結果をメモしてそれを返す。</li>
</ol>
<p>定義した 2 つの関数を適用してみる。</p>
<pre><code class="language-go">factorialTag := func(self Func[int, int]) Func[int, int] {
  return func(n int) int {
    if n == 0 {
      return 1
    }
    return n * self(n-1)
  }
}

factorial := Y(Adapt(factorialTag, Memo[int, int]()))
factorial(10) // 3628800
</code></pre>
<p>実際にメモ化ができているのかベンチマークを取ってみる。ベンチマークに利用したコードを記述する。</p>
<pre><code class="language-go">func BenchmarkFac(b *testing.B) {
  factorial := Y(factorialTag)
  for i := 0; i &lt; b.N; i++ {
    _ = factorial(i)
  }
}

func BenchmarkFacMemo(b *testing.B) {
  factorial := Y(Adapt(factorialTag, Memo[int, int]()))
  for i := 0; i &lt; b.N; i++ {
    _ = factorial(i)
  }
}
</code></pre>
<p>ベンチマークの結果としてメモ化を行ったコードが断然速くなっていることが分かる。よって無事に適用できていることが分かる。</p>
<pre><code>$ go test -benchmem -bench ./... github.com/Code-Hex/yc

goos: darwin
goarch: arm64
pkg: github.com/Code-Hex/yc
BenchmarkFac-8       	   10000	    247627 ns/op	  199980 B/op	    9999 allocs/op
BenchmarkFacMemo-8   	 5783738	       247.6 ns/op	     134 B/op	       3 allocs/op
PASS
coverage: 73.9% of statements
ok  	github.com/Code-Hex/yc	4.356s
</code></pre>
<h2 id="まとめ"><a href="#%E3%81%BE%E3%81%A8%E3%82%81" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path></svg></a>まとめ</h2>
<ul>
<li>無名関数の引数を一つにしても、返す関数に引数を持たせられれば、実質的に複数の引数を用意できる手段を紹介した。</li>
<li>この無名関数の形を利用した Y コンビネータを実装することで無名関数でも再帰処理を行うことができた。</li>
<li>プラグイン機構を用意することでメモ化処理も汎用的に行えるようにした。</li>
</ul>
<p>今回利用したコードは <a href="https://github.com/Code-Hex/yc">https://github.com/Code-Hex/yc</a> に置いた。</p>
<p>意外とまだ Go のジェネリクスのネタが少ないように思える。この記事がネタの一つになると嬉しい。</p>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>Y コンビネータは不動点演算子とも呼ばれる。Google で素直に「Y コンビネータ」で検索すると Hacker News の会社情報ばかり出てくるため、「Y コンビネータ 関数」だったり「不動点演算子」で検索すると良い。 <a href="#user-content-fnref-1" data-footnote-backref="true" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section></article><div aria-label="SNSで共有する" class="flex space-x-2 mt-8"><a href="https://b.hatena.ne.jp/entry/s/codehex.dev/note/y_combinator_in_go_generics" class="w-16 max-h-6 rounded-sm border border-blue-400" target="_blank" rel="noopener noreferrer" role="link" aria-label="Hatena Bookmarkで共有する"><div class="w-full flex justify-between items-center"><span class="bg-blue-400 hover:bg-blue-500 text-white text-sm font-bold py-px px-1">B!</span><span class="w-full text-center text-gray-600 text-sm hover:bg-blue-100 hover:bg-opacity-50">5</span></div></a><a href="https://twitter.com/intent/tweet?text=Go%20Generics%20%E3%81%A7%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%20Y%20%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%80%81%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0%E3%82%92%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AB%E3%83%A1%E3%83%A2%E5%8C%96%E3%81%99%E3%82%8B&amp;url=https://codehex.dev/note/y_combinator_in_go_generics" class="flex items-center w-20 rounded-sm bg-blue-400 hover:bg-blue-500" target="_blank" rel="noopener noreferrer" role="link" aria-label="Twitterで共有する"><div class="px-2 w-full flex justify-between items-center"><svg version="1.1" id="Logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="w-4 h-4" viewBox="0 0 248 204" xml:space="preserve"><g id="Logo_1_"><path id="white_background" fill="#fff" d="M221.95,51.29c0.15,2.17,0.15,4.34,0.15,6.53c0,66.73-50.8,143.69-143.69,143.69v-0.04 C50.97,201.51,24.1,193.65,1,178.83c3.99,0.48,8,0.72,12.02,0.73c22.74,0.02,44.83-7.61,62.72-21.66 c-21.61-0.41-40.56-14.5-47.18-35.07c7.57,1.46,15.37,1.16,22.8-0.87C27.8,117.2,10.85,96.5,10.85,72.46c0-0.22,0-0.43,0-0.64 c7.02,3.91,14.88,6.08,22.92,6.32C11.58,63.31,4.74,33.79,18.14,10.71c25.64,31.55,63.47,50.73,104.08,52.76 c-4.07-17.54,1.49-35.92,14.61-48.25c20.34-19.12,52.33-18.14,71.45,2.19c11.31-2.23,22.15-6.38,32.07-12.26 c-3.77,11.69-11.66,21.62-22.2,27.93c10.01-1.18,19.79-3.86,29-7.95C240.37,35.29,231.83,44.14,221.95,51.29z"></path></g></svg><span class="text-white text-xs font-bold py-px px-1">Tweet</span></div></a></div></div></div></main><footer role="contentinfo" class="w-full mx-auto max-w-3xl xl:max-w-5xl"><div class="text-md font-medium leading-5 divide-y divide-gray-200"><div class="mx-8 sm:mx-10 md:mx-12 pb-24 lg:pb-16"><a role="link" class="text-teal-600 hover:text-teal-700" href="/note/">← Back to the note</a></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"ogpPath":"/assets/images/350e63b3dcf2d00d0ebc8b16d189e38c.png","bookmarkCount":"5"},"__N_SSG":true},"page":"/note/y_combinator_in_go_generics","query":{},"buildId":"d3f8ba3332610b55217f7802de0371966a505fe6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>